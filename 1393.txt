//Я взял код с e-maxx и исправил, так чтобы он работал для циклических сдвигов.
//В оригинале lcp верно работало только для суффиксов, а для цикл. сдвигов нет.
#include <vector>
#include <iomanip>
#include <iostream>
#include <algorithm>
#include <string>

using namespace std;

const int alph = 256;

const int INF = 1000000000;
const int MPOW = 20;
const int N = 1 << MPOW - 1;
const int N2 = N << 1;
struct sg_tree
{
    int arr[N2];

    void build(const vector<int>& x, int n)
    {
        fill(arr, arr + N2, INF);
        for (int i = 0; i<n; i++)
            arr[i + N] = x[i];
        for (int i = N - 1; i>0; i--)
            arr[i] = min(arr[i << 1], arr[(i << 1) + 1]);
    }

    int get_min(int c, int cl, int cr, int l, int r)
    {
        if (l == cl && r == cr)
            return arr[c];
        if (l>r)
            return INF;
        int cm = cl + cr >> 1;
        return min(get_min(c << 1, cl, cm, l, min(r, cm)), get_min((c << 1) + 1, cm + 1, cr, max(l, cm + 1), r));
    }

    int get_min(int l, int r)
    {
        return get_min(1, 0, N - 1, l, r);
    }
};

vector<int> compute(string &s)
{
    int n = s.size();
    int maxn = n + alph;

    vector<int> p(n), c(n), cnt(maxn, 0);
    for (int i = 0; i<n; i++)
        cnt[s[i]]++;
    for (int i = 1; i<maxn; i++)
        cnt[i] += cnt[i - 1];
    for (int i = 0; i<n; i++)
        p[--cnt[s[i]]] = i;
    int cl = 0;
    c[p[0]] = cl;
    for (int i = 1; i<n; i++)
    {
        if (s[p[i]] != s[p[i - 1]])cl++;
        c[p[i]] = cl;
    }
    vector<int> lcp(n, 0);
    for (int i = 1; i<n; i++)
        lcp[i] = c[p[i]] == c[p[i - 1]];
    vector<int> pn(n), cn(n), lcpn(n);
    vector<int> rpos(n), lpos(n);
    int k = 1;
    while (k<n)
    {
        fill(begin(cnt), end(cnt), 0);
        for (int i = 0; i<n; i++)
            rpos[c[p[i]]] = i;
        for (int i = n - 1; i >= 0; i--)
            lpos[c[p[i]]] = i;
        for (int i = 0; i<n; i++)
        {
            pn[i] = p[i] - k;
            if (pn[i]<0)pn[i] += n;
        }
        for (int i = 0; i<n; i++)
            cnt[c[i]]++;
        for (int i = 1; i<maxn; i++)
            cnt[i] += cnt[i - 1];
        for (int i = n - 1; i >= 0; i--)
            p[--cnt[c[pn[i]]]] = pn[i];
        cl = 0;
        cn[p[0]] = 0;
        for (int i = 1; i<n; i++)
        {
            int m1 = (p[i] + k) % n, m2 = (p[i - 1] + k) % n;
            if (c[p[i]] != c[p[i - 1]] || c[m1] != c[m2])cl++;
            cn[p[i]] = cl;
        }

        sg_tree rmq;
        rmq.build(lcp, n);
        for (int i = 1; i<n; i++)
        {
            int a = p[i], b = p[i - 1];
            if (c[a] != c[b])
                lcpn[i] = lcp[lpos[c[a]]];
            else
            {
                int aa = (a + k) % n, bb = (b + k) % n;
                if (c[aa] == c[bb])
                    lcpn[i] = k << 1;
                else
                    lcpn[i] = k + rmq.get_min(lpos[c[bb]] + 1, rpos[c[aa]]);
            }
            lcpn[i] = min(n, lcpn[i]);
        }
        copy(begin(cn), end(cn), begin(c));
        copy(begin(lcpn), end(lcpn), begin(lcp));
        k <<= 1;
    }

    return lcp;
}

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    int n;
    cin >> n;
    string a;
    cin >> a;

    vector<int> computed = compute(a);

    long long sum = 0;
    for (int i = 0; i < n; ++i)
        sum += computed[i];

    cout << std::fixed << std::setprecision(3) << (double)sum / (n - 1) << endl;
}
